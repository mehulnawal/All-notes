# âœ… DSA Pattern Recognition Sheet

| Index | Pattern Name               | How to Identify                                                               | Keywords / Triggers                                                   |
| ----- | -------------------------- | ----------------------------------------------------------------------------- | --------------------------------------------------------------------- |
| 1     | Sliding Window             | Look for max/min/sum in subarrays of fixed or variable size                   | subarray, window, longest, shortest, fixed size, at most K            |
| 2     | Two Pointers               | Use two indices from start and end to solve problems on sorted arrays/strings | sorted, reverse, pair, closest sum, move pointers                     |
| 3     | Fast & Slow Pointers       | Detect cycle, middle, or repeat pattern in linked lists or arrays             | cycle, loop, repeat, detect, slow & fast, middle node                 |
| 4     | Merge Intervals            | Merge overlapping intervals or handle calendar/time ranges                    | merge, overlap, intervals, range, schedule                            |
| 5     | Binary Search              | Find element or condition in sorted array or answer space                     | sorted, find, search, minimum/maximum, boundary, Kth                  |
| 6     | Top K Elements (Heap)      | Find top K frequent/largest/smallest values using priority queue              | top K, Kth, frequent, largest, heap, priority                         |
| 7     | Prefix Sum / Cumulative    | Range sum/count in array; improve brute-force by precomputing sums            | sum between, subarray sum, prefix sum, count in range                 |
| 8     | Backtracking               | Explore all paths/choices recursively with undoing step                       | all ways, generate, combinations, permutations, sudoku, search        |
| 9     | Dynamic Programming (DP)   | Break problem into subproblems and store their results                        | max/min value, count ways, overlapping subproblems, fib-like          |
| 10    | Greedy                     | Make best choice at each step for global solution                             | minimize, maximize, earliest, least, optimal step                     |
| 11    | BFS (Breadth-First Search) | Find shortest path or level-wise traversal in grid/tree                       | shortest path, minimum moves, level order, queue, grid                |
| 12    | DFS (Depth-First Search)   | Explore all paths deeply; used for connected components                       | flood fill, maze, all paths, traversal, recursive graph               |
| 13    | Union Find (DSU)           | Detect cycle in graph, or group connectivity problems                         | union, find, disjoint sets, connected components, groups              |
| 14    | Bit Manipulation           | Work with bits for optimization or state tracking                             | XOR, AND, OR, set bit, toggle, power of 2, binary tricks              |
| 15    | Recursion / Divide & Conq. | Divide the problem, solve recursively, and combine results                    | merge sort, quick sort, binary search, divide and conquer             |
| 16    | Trie (Prefix Tree)         | Efficient prefix-based search and insert operations                           | startsWith, prefix search, dictionary, word suggestions               |
| 17    | Monotonic Stack / Queue    | Find next greater/smaller element or stock span problems                      | next greater/smaller, span, histogram, maintain increasing/decreasing |
